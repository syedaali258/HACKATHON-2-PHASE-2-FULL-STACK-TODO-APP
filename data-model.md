# Data Model: Frontend Application (Next.js App Router)

**Feature**: 004-nextjs-frontend
**Date**: 2026-02-08
**Purpose**: Define TypeScript types and data structures for the frontend application

## Overview

This document defines the TypeScript types and data models used in the Next.js frontend application. These models represent the data structures consumed from the backend API and used throughout the UI components.

---

## Core Entities

### 1. Task (UI Representation)

Represents a task as displayed in the user interface, matching the backend API response format.

**TypeScript Definition**:
```typescript
// types/task.ts

export interface Task {
  id: number
  user_id: string
  title: string
  description: string | null
  is_completed: boolean
  created_at: string  // ISO 8601 datetime string
  updated_at: string  // ISO 8601 datetime string
}

export interface TaskCreateInput {
  title: string
  description?: string
  is_completed?: boolean
}

export interface TaskUpdateInput {
  title?: string
  description?: string
  is_completed?: boolean
}
```

**Field Descriptions**:

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `id` | number | Yes (response only) | Unique task identifier | Auto-generated by backend |
| `user_id` | string | Yes (response only) | Owner's user ID from JWT | Auto-assigned by backend |
| `title` | string | Yes | Task title | 1-200 characters, not empty/whitespace |
| `description` | string \| null | No | Task description | Max 2000 characters |
| `is_completed` | boolean | Yes | Completion status | Defaults to false |
| `created_at` | string | Yes (response only) | Creation timestamp | ISO 8601 format |
| `updated_at` | string | Yes (response only) | Last update timestamp | ISO 8601 format |

**Usage Context**:
- Received from GET /api/tasks (list)
- Received from GET /api/tasks/{id} (single)
- Received from POST /api/tasks (create response)
- Received from PUT /api/tasks/{id} (update response)

**State Management**:
- Stored in component state (useState)
- No global state management required
- Optimistic updates for better UX

---

### 2. User Session

Represents the authenticated user's session state managed by Better Auth.

**TypeScript Definition**:
```typescript
// types/auth.ts

export interface UserSession {
  user: {
    id: string
    email: string
    name?: string
  }
  accessToken: string
  expiresAt: number  // Unix timestamp
}

export interface SignUpInput {
  email: string
  password: string
  name?: string
}

export interface SignInInput {
  email: string
  password: string
}
```

**Field Descriptions**:

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|------------|
| `user.id` | string | Yes | Unique user identifier | From JWT 'sub' claim |
| `user.email` | string | Yes | User's email address | Valid email format |
| `user.name` | string | No | User's display name | Optional |
| `accessToken` | string | Yes | JWT access token | Signed by BETTER_AUTH_SECRET |
| `expiresAt` | number | Yes | Token expiration time | Unix timestamp |

**Usage Context**:
- Managed by Better Auth client
- Accessed via `useSession()` hook
- Stored in httpOnly cookies
- Used for route protection and API authentication

---

### 3. API Response Types

Standard response formats for API operations.

**TypeScript Definition**:
```typescript
// types/api.ts

export interface ApiResponse<T> {
  data: T
  status: number
}

export interface ApiError {
  message: string
  status: number
  errors?: Record<string, string[]>  // Validation errors
}

export interface PaginatedResponse<T> {
  data: T[]
  total: number
  page: number
  pageSize: number
}
```

**Usage Context**:
- Wraps all API responses
- Provides consistent error handling
- Type-safe API client methods

---

### 4. UI State Types

Component-level state for loading, errors, and form states.

**TypeScript Definition**:
```typescript
// types/ui.ts

export interface LoadingState {
  isLoading: boolean
  message?: string
}

export interface ErrorState {
  hasError: boolean
  message: string
  code?: string
}

export interface FormState<T> {
  values: T
  errors: Partial<Record<keyof T, string>>
  isSubmitting: boolean
  isDirty: boolean
}

export type TaskFilter = "all" | "active" | "completed"

export type TaskSort = "created_asc" | "created_desc" | "title_asc" | "title_desc"
```

**Usage Context**:
- Component-level state management
- Form validation and submission
- Loading and error indicators
- Future: filtering and sorting (out of scope for MVP)

---

## Validation Schemas

Zod schemas for client-side validation (matching backend validation rules).

**TypeScript Definition**:
```typescript
// lib/utils/validation.ts
import { z } from "zod"

export const taskCreateSchema = z.object({
  title: z.string()
    .min(1, "Title is required")
    .max(200, "Title must be 200 characters or less")
    .trim()
    .refine(val => val.length > 0, "Title cannot be empty or whitespace"),
  description: z.string()
    .max(2000, "Description must be 2000 characters or less")
    .optional()
    .or(z.literal("")),
  is_completed: z.boolean().default(false),
})

export const taskUpdateSchema = z.object({
  title: z.string()
    .min(1, "Title is required")
    .max(200, "Title must be 200 characters or less")
    .trim()
    .optional(),
  description: z.string()
    .max(2000, "Description must be 2000 characters or less")
    .optional()
    .or(z.literal("")),
  is_completed: z.boolean().optional(),
})

export const signUpSchema = z.object({
  email: z.string()
    .email("Invalid email address")
    .min(1, "Email is required"),
  password: z.string()
    .min(8, "Password must be at least 8 characters")
    .max(100, "Password must be 100 characters or less"),
  name: z.string()
    .max(100, "Name must be 100 characters or less")
    .optional(),
})

export const signInSchema = z.object({
  email: z.string()
    .email("Invalid email address")
    .min(1, "Email is required"),
  password: z.string()
    .min(1, "Password is required"),
})

// Type inference from schemas
export type TaskCreateInput = z.infer<typeof taskCreateSchema>
export type TaskUpdateInput = z.infer<typeof taskUpdateSchema>
export type SignUpInput = z.infer<typeof signUpSchema>
export type SignInInput = z.infer<typeof signInSchema>
```

---

## Data Flow

### Task Creation Flow

```
User Input (CreateTaskForm)
  ↓
Client-side validation (Zod schema)
  ↓
API Client (POST /api/tasks with JWT)
  ↓
Backend API (creates task with user_id from JWT)
  ↓
Response (Task object)
  ↓
Optimistic UI update (add to local state)
  ↓
Dashboard refresh (show new task)
```

### Task Update Flow

```
User Action (toggle completion / edit form)
  ↓
Optimistic UI update (update local state immediately)
  ↓
API Client (PUT /api/tasks/{id} with JWT)
  ↓
Backend API (updates task, verifies ownership)
  ↓
Response (updated Task object)
  ↓
Confirm UI state (or revert on error)
```

### Authentication Flow

```
User Input (SignInForm)
  ↓
Client-side validation (Zod schema)
  ↓
Better Auth client (POST to auth endpoint)
  ↓
Backend Auth Service (verifies credentials, issues JWT)
  ↓
Response (JWT token + user info)
  ↓
Better Auth stores token in httpOnly cookie
  ↓
Redirect to dashboard
  ↓
Middleware verifies token on protected routes
```

---

## Type Safety Guarantees

1. **Compile-time type checking**: All API responses typed with TypeScript
2. **Runtime validation**: Zod schemas validate user input before API calls
3. **Type inference**: Zod schemas automatically generate TypeScript types
4. **Exhaustive checking**: Union types (TaskFilter, TaskSort) ensure all cases handled
5. **Null safety**: Explicit null/undefined handling with TypeScript strict mode

---

## Relationship to Backend Data Model

The frontend data models are designed to match the backend API contracts exactly:

| Frontend Type | Backend Model | Mapping |
|---------------|---------------|---------|
| `Task` | `Task` (SQLModel) | 1:1 exact match |
| `TaskCreateInput` | `TaskCreate` (Pydantic) | 1:1 exact match |
| `TaskUpdateInput` | `TaskUpdate` (Pydantic) | 1:1 exact match |
| `UserSession.user.id` | JWT 'sub' claim | Extracted from token |

**Consistency Rules**:
- Field names must match exactly (snake_case in API, camelCase in TypeScript)
- Validation rules must match backend constraints
- Date formats must be ISO 8601 strings
- Null handling must match backend nullable fields

---

## Future Considerations (Out of Scope)

- Task categories/tags (would add `tags: string[]` field)
- Task priority levels (would add `priority: "low" | "medium" | "high"` field)
- Task due dates (would add `due_date: string | null` field)
- Task attachments (would add `attachments: Attachment[]` field)
- Pagination for large task lists (would add `PaginatedResponse<Task>` type)
- Real-time updates (would add WebSocket event types)
- Offline support (would add local storage sync types)

---

## Notes

- All timestamps are ISO 8601 strings (e.g., "2026-02-08T12:34:56.789Z")
- All API requests include JWT token in Authorization header
- All user-scoped data filtered by user_id on backend (frontend trusts backend)
- No sensitive data stored in frontend state (passwords, tokens in memory only)
- TypeScript strict mode enabled for maximum type safety
